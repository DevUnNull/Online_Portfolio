<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>UnNull ‚Äî SOLID Principles</title>
    <style>
        body {
            font-family: Consolas, monospace;
            background: #0d1a26;
            color: #00ff99;
            padding: 30px
        }

        a {
            color: #00ff99;
            text-decoration: none;
            transition: all .3s ease
        }

        a:hover {
            text-decoration: underline
        }

        .container {
            max-width: 950px;
            margin: auto;
            background: rgba(0, 0, 0, .85);
            padding: 24px;
            border: 2px solid #00ff99
        }

        .back {
            margin-bottom: 18px;
            display: inline-block;
            padding: 10px 20px;
            border: 2px solid #00ff99;
            transition: all .3s ease
        }

        .back:hover {
            background: rgba(0, 255, 153, .1);
            box-shadow: 0 0 10px rgba(0, 255, 153, .5)
        }

        h1 {
            color: #ccff00;
            text-shadow: 0 0 10px #ccff00;
            font-size: 28px;
            margin-bottom: 18px;
            text-transform: uppercase;
            letter-spacing: 2px
        }

        h2 {
            color: #00ff99;
            font-size: 18px;
            margin: 16px 0 8px
        }

        p,
        li {
            font-size: 14px;
            line-height: 1.6
        }

        .note {
            color: #00ffff
        }

        .section {
            border-top: 1px dashed rgba(0, 255, 153, .15);
            padding-top: 12px;
            margin-top: 12px
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px
        }

        .card {
            border: 1px solid rgba(0, 255, 153, .3);
            padding: 12px;
            background: rgba(0, 255, 153, .05)
        }

        .table {
            width: 100%;
            border-collapse: collapse
        }

        .table th,
        .table td {
            border: 1px solid rgba(0, 255, 153, .25);
            padding: 8px;
            font-size: 14px
        }

        .code {
            background: #0a1628;
            border: 1px solid rgba(0, 255, 153, .25);
            padding: 12px;
            overflow: auto;
            margin: 10px 0;
            color: #e6fff5
        }

        .toc {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0
        }

        .toc a {
            padding: 6px 10px;
            border: 1px solid rgba(0, 255, 153, .35)
        }

        .callout {
            background: rgba(0, 255, 153, .1);
            border-left: 3px solid #00ff99;
            padding: 10px;
            margin: 10px 0
        }
    </style>
</head>

<body>
    <div class="container">
        <a href="knowledge.html#solid" class="back">‚Üê Quay l·∫°i m·ª•c SOLID</a>
        <a href="index.html" class="back" style="margin-left:8px">‚Üê V·ªÅ trang h·ªì s∆°</a>
        <h1>üìê SOLID Principles</h1>

        <div class="toc">
            <a href="#intro">Gi·ªõi thi·ªáu</a>
            <a href="#overview">T·ªïng quan</a>
            <a href="#srp">SRP</a>
            <a href="#ocp">OCP</a>
            <a href="#lsp">LSP</a>
            <a href="#isp">ISP</a>
            <a href="#dip">DIP</a>
            <a href="#conclusion">K·∫øt lu·∫≠n</a>
        </div>

        <div class="section" id="intro">
            <h2>I. Gi·ªõi Thi·ªáu & T·∫ßm Quan Tr·ªçng</h2>
            <ul>
                <li>NgƒÉn ng·ª´a h·ªón ƒë·ªôn: d√πng nguy√™n t·∫Øc thi·∫øt k·∫ø ƒë·ªÉ tr√°nh tr·ªü th√†nh m·ªõ kh√≥ qu·∫£n l√Ω.</li>
                <li>C√¢n b·∫±ng: gi·ªØ c·∫•u tr√∫c r√µ r√†ng ƒë·ªìng th·ªùi linh ho·∫°t ƒë·ªÉ m·ªü r·ªông.</li>
                <li>Ti·∫øn ƒë·ªô ·ªïn ƒë·ªãnh: gi·∫£m c√¥ng vi·ªác kh√¥ng c·∫ßn thi·∫øt, tr√°nh ƒë·∫≠p ƒëi l√†m l·∫°i.</li>
            </ul>
            <div class="callout">
                <span class="note">L∆∞u √Ω:</span> hi·ªÉu intention sau m·ªói quy t·∫Øc ƒë·ªÉ bi·∫øt khi n√†o n√™n theo, khi n√†o c·∫ßn
                ph√° v·ª° c√≥ ch·ªß ƒë√≠ch.
            </div>
        </div>

        <div class="section" id="overview">
            <h2>II. Gi·ªõi Thi·ªáu B·ªô Nguy√™n T·∫Øc SOLID</h2>
            <table class="table">
                <tr>
                    <th>Ch·ªØ c√°i</th>
                    <th>Nguy√™n t·∫Øc</th>
                    <th>T√™n ti·∫øng Anh</th>
                </tr>
                <tr>
                    <td>S</td>
                    <td>Tr√°ch nhi·ªám ƒë∆°n l·∫ª</td>
                    <td>Single Responsibility Principle</td>
                </tr>
                <tr>
                    <td>O</td>
                    <td>M·ªü/ƒê√≥ng</td>
                    <td>Open/Closed Principle</td>
                </tr>
                <tr>
                    <td>L</td>
                    <td>Thay th·∫ø Liskov</td>
                    <td>Liskov Substitution Principle</td>
                </tr>
                <tr>
                    <td>I</td>
                    <td>Ph√¢n t√°ch Interface</td>
                    <td>Interface Segregation Principle</td>
                </tr>
                <tr>
                    <td>D</td>
                    <td>ƒê·∫£o ng∆∞·ª£c Ph·ª• thu·ªôc</td>
                    <td>Dependency Inversion Principle</td>
                </tr>
            </table>
        </div>

        <div class="section" id="srp">
            <h2>1. Single Responsibility Principle (SRP)</h2>
            <ul>
                <li>M·ªôt class ch·ªâ c√≥ m·ªôt l√Ω do ƒë·ªÉ thay ƒë·ªïi.</li>
                <li>Trong Unity, t√°ch logic ki·ªÉm tra m·∫∑t ƒë·∫•t kh·ªèi ƒëi·ªÅu khi·ªÉn ƒë·∫ßu v√†o.</li>
                <li>Ngo·∫°i l·ªá th·ª±c t·∫ø: n·∫øu class ƒë∆∞·ª£c thi·∫øt k·∫ø ch·ªâ ph·ª•c v·ª• Player ho·∫∑c m·ªôt ƒë·ªëi t∆∞·ª£ng c·ª• th·ªÉ v√† kh√¥ng c·∫ßn
                    t√°i s·ª≠ d·ª•ng cho ƒë·ªëi t∆∞·ª£ng kh√°c, vi·ªác g·ªôp c√°c logic li√™n quan v·∫´n ph√π h·ª£p v·ªõi SRP v√¨ class ch·ªâ c√≥ m·ªôt
                    l√Ω do thay ƒë·ªïi g·∫Øn v·ªõi ƒë·ªëi t∆∞·ª£ng ƒë√≥.</li>
            </ul>
            <div class="grid">
                <div class="card">
                    <strong>V·∫•n ƒë·ªÅ</strong>
                    <p>Movement v√† Ground Check g·ªôp chung l√†m kh√≥ t√°i s·ª≠ d·ª•ng.</p>
                </div>
                <div class="card">
                    <strong>Gi·∫£i ph√°p</strong>
                    <p>D√πng k·∫ø th·ª´a: l·ªõp n·ªÅn ki·ªÉm tra m·∫∑t ƒë·∫•t, l·ªõp d·∫´n xu·∫•t x·ª≠ l√Ω ƒëi·ªÅu khi·ªÉn.</p>
                </div>
            </div>
            <p><strong>V√≠ d·ª• sai (vi ph·∫°m SRP)</strong></p>
            <div class="code">
                <pre>using UnityEngine;

public class PlayerController : MonoBehaviour {
    bool grounded;
    int score;
    void Update() {
        grounded = Physics.Raycast(transform.position, Vector3.down, 0.1f);
        if (grounded && Input.GetButtonDown("Jump")) {}
        if (Input.GetKeyDown(KeyCode.P)) score++;
    }
}
</pre>
            </div>
            <p><strong>V√≠ d·ª• ƒë√∫ng (t√°ch Ground Check kh·ªèi Input)</strong></p>
            <div class="code">
                <pre>using UnityEngine;

public class Groundable : MonoBehaviour {
    protected bool IsGrounded() {
        return Physics.Raycast(transform.position, Vector3.down, 0.1f);
    }
}

public class Controllable : Groundable {
    void Update() {
        if (IsGrounded() && Input.GetButtonDown("Jump")) { }
    }
}

public class Moveable : Groundable {
    void Update() { }
}
</pre>
            </div>
        </div>

        <div class="section" id="ocp">
            <h2>2. Open/Closed Principle (OCP)</h2>
            <ul>
                <li>M·ªü r·ªông b·∫±ng l·ªõp m·ªõi, kh√¥ng s·ª≠a l·ªõp ƒëang ch·∫°y ·ªïn.</li>
                <li>Gi·∫£i ph√°p: Abstraction qua Interface ho·∫∑c Inheritance.</li>
            </ul>
            <p><strong>V√≠ d·ª• sai (vi ph·∫°m OCP)</strong></p>
            <div class="code">
                <pre>using UnityEngine;
public class Collector : MonoBehaviour {
    void OnTriggerEnter(Collider other) {
        if (other.GetComponent&lt;PointsPickup&gt;() != null) {}
        else if (other.GetComponent&lt;HealthPickup&gt;() != null) {}
    }
}
public class PointsPickup : MonoBehaviour {}
public class HealthPickup : MonoBehaviour {}
</pre>
            </div>
            <p><strong>V√≠ d·ª• ƒë√∫ng (d√πng Interface ƒë·ªÉ m·ªü r·ªông)</strong></p>
            <div class="code">
                <pre>public interface ICollectable {
    void Collect(GameObject collector);
}

using UnityEngine;
public class Collector : MonoBehaviour {
    void OnTriggerEnter(Collider other) {
        var c = other.GetComponent&lt;ICollectable&gt;();
        if (c != null) c.Collect(gameObject);
    }
}

public class PointsPickup : MonoBehaviour, ICollectable {
    public void Collect(GameObject collector) { }
}

public class HealthPickup : MonoBehaviour, ICollectable {
    public void Collect(GameObject collector) { }
}
</pre>
            </div>
        </div>

        <div class="section" id="lsp">
            <h2>3. Liskov Substitution Principle (LSP)</h2>
            <ul>
                <li>ƒê·ªëi t∆∞·ª£ng d·∫´n xu·∫•t ph·∫£i thay th·∫ø ƒë∆∞·ª£c ƒë·ªëi t∆∞·ª£ng c∆° s·ªü m√† kh√¥ng ph√° v·ª° h√†nh vi mong ƒë·ª£i.</li>
                <li>Trong Unity: c√°c lo·∫°i Collider ƒë·ªÅu l√† subtype c·ªßa Collider, API d√πng ƒë∆∞·ª£c nh∆∞ nhau.</li>
                <li>Gi·ªØ h·ª£p ƒë·ªìng nh·∫•t qu√°n: kh√¥ng thay ƒë·ªïi √Ω nghƒ©a tham s·ªë/gi√° tr·ªã tr·∫£ v·ªÅ.</li>
            </ul>
            <p><strong>V√≠ d·ª• sai (vi ph·∫°m LSP)</strong></p>
            <div class="code">
                <pre>public class Ellipse {
    public virtual float Width { get; set; }
    public virtual float Height { get; set; }
}
public class Circle : Ellipse {
    public override float Width { get { return base.Width; } set { base.Width = value; base.Height = value; } }
    public override float Height { get { return base.Height; } set { base.Width = value; base.Height = value; } }
}
</pre>
            </div>
            <p><strong>V√≠ d·ª• ƒë√∫ng</strong></p>
            <div class="code">
                <pre>using UnityEngine;
public interface IShape { float Area(); }
public class Circle : IShape { public float Radius; public float Area() { return Mathf.PI * Radius * Radius; } }
public class EllipseShape : IShape { public float A; public float B; public float Area() { return Mathf.PI * A * B; } }
</pre>
            </div>
        </div>

        <div class="section" id="isp">
            <h2>4. Interface Segregation Principle (ISP)</h2>
            <ul>
                <li>Kh√¥ng bu·ªôc class ph·∫£i implement nh·ªØng th·ª© kh√¥ng d√πng.</li>
                <li>T√°ch th√†nh nhi·ªÅu interface nh·ªè theo nhu c·∫ßu c·ª• th·ªÉ.</li>
            </ul>
            <p><strong>V√≠ d·ª• sai (vi ph·∫°m ISP)</strong></p>
            <div class="code">
                <pre>public interface IEnemy {
    void Damage(float amount);
    void Stun(float duration);
    void Move();
}
using UnityEngine;
public class WoodenCrateWrong : MonoBehaviour, IEnemy {
    public void Damage(float amount) {}
    public void Stun(float duration) {}
    public void Move() {}
}
</pre>
            </div>
            <p><strong>V√≠ d·ª• ƒë√∫ng (t√°ch th√†nh nhi·ªÅu interface nh·ªè)</strong></p>
            <div class="code">
                <pre>public interface IDamageable { void Damage(float amount); }
public interface IStunnable { void Stun(float duration); }

using UnityEngine;
public class WoodenCrate : MonoBehaviour, IDamageable {
    public void Damage(float amount) { }
}
</pre>
            </div>
        </div>

        <div class="section" id="dip">
            <h2>5. Dependency Inversion Principle (DIP)</h2>
            <ul>
                <li>High-level ph·ª• thu·ªôc v√†o abstraction, kh√¥ng ph·ª• thu·ªôc tr·ª±c ti·∫øp v√†o low-level c·ª• th·ªÉ.</li>
                <li>D√πng Dependency Injection ƒë·ªÉ g·∫Øn implementation khi ch·∫°y.</li>
            </ul>
            <p><strong>V√≠ d·ª• sai (vi ph·∫°m DIP)</strong></p>
            <div class="code">
                <pre>using UnityEngine;
public class MusicPlayerWrong : MonoBehaviour {
    SpecificMusicSequencer _sequencer = new SpecificMusicSequencer();
    void Start() {
        if (!_sequencer.IsPlaying()) _sequencer.StartNewSong(new SongData());
    }
}
public class SpecificMusicSequencer {
    public void StartNewSong(SongData data) {}
    public bool IsPlaying() { return true; }
}
public struct SongData {}
</pre>
            </div>
            <p><strong>V√≠ d·ª• ƒë√∫ng (High-level ph·ª• thu·ªôc v√†o abstraction)</strong></p>
            <div class="code">
                <pre>public interface IMusicInteraction {
    void StartNewSong(SongData data);
    bool IsPlaying();
}

using UnityEngine;
public class MusicPlayer : MonoBehaviour {
    [SerializeField] MonoBehaviour sequencerComponent;
    IMusicInteraction _sequencer;
    void Awake() { _sequencer = (IMusicInteraction)sequencerComponent; }
    void Start() { if (!_sequencer.IsPlaying()) _sequencer.StartNewSong(new SongData()); }
}

public class SpecificMusicSequencer : MonoBehaviour, IMusicInteraction {
    public void StartNewSong(SongData data) { }
    public bool IsPlaying() { return true; }
}

public struct SongData {}
</pre>
            </div>
        </div>

        <div class="section" id="conclusion">
            <h2>IV. K·∫øt Lu·∫≠n</h2>
            <ul>
                <li>SRP ƒë·ªÉ t√°ch tr√°ch nhi·ªám, d·ªÖ t√°i s·ª≠ d·ª•ng.</li>
                <li>OCP ƒë·ªÉ m·ªü r·ªông an to√†n b·∫±ng l·ªõp m·ªõi.</li>
                <li>LSP ƒë·ªÉ thay th·∫ø nh·∫•t qu√°n.</li>
                <li>ISP ƒë·ªÉ interface g·ªçn, ƒë√∫ng nhu c·∫ßu.</li>
                <li>DIP ƒë·ªÉ gi·∫£m ph·ª• thu·ªôc c·ª©ng, d·ªÖ test v√† thay th·∫ø.</li>
            </ul>
            <p class="note">M·ª•c ti√™u l√† code c·∫≠p nh·∫≠t ·ªïn ƒë·ªãnh, d·ªÖ b·∫£o tr√¨ v√† m·ªü r·ªông.</p>
        </div>
    </div>
</body>

</html>